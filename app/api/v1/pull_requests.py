from __future__ import annotations

from typing import Any

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from pydantic import BaseModel
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_session
from app.core.dependencies import CurrentUser
from app.core.logging import get_logger
from app.models.task import Task, TaskOutput
from app.services.github_pr_service import GitHubPRService


class PRCreateRequest(BaseModel):
    title: str | None = None
    description: str | None = None

logger = get_logger(__name__)
router = APIRouter()
bearer_scheme = HTTPBearer()


@router.post(
    "/tasks/{task_id}/variations/{variation_id}/pull-request",
    status_code=status.HTTP_201_CREATED,
)
async def create_task_variation_pull_request(
    task_id: int,
    variation_id: int,
    pr_request: PRCreateRequest = PRCreateRequest(),
    current_user: CurrentUser,
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: AsyncSession = Depends(get_session),
) -> dict[str, Any]:
    """Create a GitHub pull request for the specified task variation.

    The pull request will embed a markdown file containing the AI-generated
    summary and diff so that the branch differs from the default branch.
    """

    # Retrieve the task and validate ownership
    task_result = await db.execute(select(Task).where(Task.id == task_id))
    task: Task | None = task_result.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    if task.user_id and task.user_id != current_user.id:
        # Simple access control – allow if the task belongs to the user.  In
        # dev/debug environments this check may be relaxed elsewhere but we
        # still enforce it here.
        raise HTTPException(status_code=403, detail="Forbidden")
    if not task.github_url:
        raise HTTPException(status_code=400, detail="Task is not associated with a GitHub repository")

    # Get the latest summary and diff for the variation
    summary_q = (
        select(TaskOutput)
        .where(
            TaskOutput.task_id == task_id,
            TaskOutput.variation_id == variation_id,
            TaskOutput.output_type.in_(["summary", "job_summary"]),
        )
        .order_by(TaskOutput.timestamp.desc())
        .limit(1)
    )
    diff_q = (
        select(TaskOutput)
        .where(
            TaskOutput.task_id == task_id,
            TaskOutput.variation_id == variation_id,
            TaskOutput.output_type == "diffs",
        )
        .order_by(TaskOutput.timestamp.desc())
        .limit(1)
    )

    summary_res = await db.execute(summary_q)
    diff_res = await db.execute(diff_q)
    summary_output: TaskOutput | None = summary_res.scalar_one_or_none()
    diff_output: TaskOutput | None = diff_res.scalar_one_or_none()

    if not diff_output:
        raise HTTPException(status_code=400, detail="No diff data found for the selected variation")

    summary_content = summary_output.content if summary_output else ""
    diff_content = diff_output.content or ""

    token = credentials.credentials
    pr_service = GitHubPRService(token)

    # Use custom title/description if provided, otherwise use defaults
    pr_title = pr_request.title or f"AIdeator – Task {task_id} Variation {variation_id + 1}"
    pr_body = pr_request.description or summary_content or "Automated changes generated by AIdeator."

    try:
        pr_url = await pr_service.create_pr(
            repo_http_url=task.github_url,
            title=pr_title,
            body=pr_body,
            diff_content=diff_content,
        )
    except Exception as exc:  # noqa: BLE001
        logger.error("Failed to create PR: %s", exc)
        raise HTTPException(status_code=500, detail="Failed to create pull request") from exc

    # Return PR URL so the frontend can redirect/open it
    return {"pr_url": pr_url}