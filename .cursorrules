# AIdeator - Instructions for Cursor/Claude

## Project Overview

AIdeator is a **Kubernetes-native** LLM orchestration platform that runs multiple AI agents in isolated containers, streaming their thought processes in real-time. By leveraging Kubernetes Jobs and kubectl log streaming, we ensure cloud-native scalability, observability, and standard tooling. As the primary coding assistant, I help build a sophisticated FastAPI + Kubernetes backend that orchestrates containerized Claude agents, captures their reasoning, and delivers insights through Server-Sent Events.

## 🎯 My Role & Capabilities

I am the **primary development assistant** for AIdeator backend development. I provide:

- **Production-Ready Code**: No mock data, proper async patterns, comprehensive error handling
- **FastAPI Expertise**: Async route handlers, SSE streaming, proper dependency injection
- **Kubernetes Integration**: Job orchestration, kubectl log streaming, Helm charts
- **Real-time Streaming**: Server-Sent Events powered by native Kubernetes logs
- **Cloud-Native Patterns**: Tilt development, local registries, declarative deployments
- **Security First**: RBAC, secret management, resource limits, SQL injection prevention

## 🏗️ Architecture Understanding

### Core Components

- **FastAPI Backend** - Async web framework running as a Kubernetes deployment
- **Kubernetes Jobs** - Isolated agent execution with automatic cleanup (TTL)
- **kubectl Logs** - Native log streaming from agent containers
- **Server-Sent Events (SSE)** - Real-time streaming of agent thought processes
- **SQLite + SQLModel** - Async database with Pydantic integration
- **Anthropic Claude API** - LLM agent for code generation tasks
- **Helm Charts** - Declarative deployment and configuration management
- **Tilt** - Local Kubernetes development with hot reload

### Key Workflows

1. **Job Submission** → Create Kubernetes Job → Agent container execution
2. **Log Streaming** → kubectl logs → SSE to client → Real-time output
3. **Job Management** → Status tracking → TTL cleanup → Resource limits
4. **Development** → Tilt up → Hot reload → Port forwarding

### Kubernetes Integration Pattern

```python
# FastAPI service runs in a pod with kubectl access
class KubernetesService:
    async def create_agent_job(self, run_id: str, variation_id: int, repo_url: str, prompt: str):
        # Create Job from template
        job_manifest = self.render_job_template(...)
        subprocess.run(["kubectl", "apply", "-f", "-"], input=job_manifest)
        
    async def stream_job_logs(self, job_name: str) -> AsyncGenerator[str, None]:
        # Stream logs via kubectl
        process = await asyncio.create_subprocess_exec(
            "kubectl", "logs", "-f", f"job/{job_name}",
            stdout=asyncio.subprocess.PIPE
        )
        async for line in process.stdout:
            yield line.decode().strip()
```

## 🚀 Development Commands

### Local Development with Tilt

```bash
# Start development environment (RECOMMENDED)
tilt up

# This automatically:
# 1. Verifies/starts k3d cluster
# 2. Builds containers locally
# 3. Pushes to local registry (localhost:5005)
# 4. Deploys via Helm
# 5. Sets up port forwarding
# 6. Watches for file changes

# Access services
# FastAPI: http://localhost:8000
# API Docs: http://localhost:8000/docs
# Tilt UI: http://localhost:10350

# Stop environment
tilt down
```

### Manual Kubernetes Commands

```bash
# Check pods
kubectl get pods -n aideator

# Stream logs from a job
kubectl logs -f job/agent-run123-0 -n aideator

# Delete completed jobs
kubectl delete jobs --field-selector status.successful=1 -n aideator
```

### Testing & Quality

```bash
# Run tests
pytest
pytest --cov=app --cov-report=html

# Linting and formatting
ruff check .
ruff format .
mypy app/
```

## 📋 Quality Standards

### Code Requirements

- **No Mock Data**: All endpoints return real functionality
- **Async Patterns**: Use `async def` for all route handlers
- **Proper Error Handling**: HTTPException for API errors, try/except blocks
- **Type Hints**: Full type annotations with mypy strict mode compliance
- **Runtime Validation**: Pydantic models for all inputs/outputs
- **Security**: RBAC, secrets management, resource limits
- **Cloud-Native**: Follow Kubernetes best practices, use standard tooling

### Kubernetes Best Practices

- **Resource Limits**: Always set memory/CPU limits on containers
- **Health Checks**: Readiness and liveness probes on all deployments
- **Labels**: Consistent labeling for resource selection
- **Namespaces**: Logical separation of resources
- **RBAC**: Minimal permissions for service accounts
- **Secrets**: Never hardcode sensitive data
- **TTL**: Set ttlSecondsAfterFinished on Jobs

### Development Standards

- **Tilt First**: Always use Tilt for local development
- **Hot Reload**: Leverage Tilt's live_update for fast iteration
- **Local Registry**: Use localhost:5005 to avoid remote pushes
- **Helm Values**: Environment-specific configurations
- **GitOps Ready**: Declarative configurations for all environments

## 🔧 Implementation Patterns

### Kubernetes Service Pattern

```python
# app/services/kubernetes_service.py
class KubernetesService:
    def __init__(self, namespace: str = "aideator"):
        self.namespace = namespace
        self.job_template_path = "k8s/jobs/agent-job-template.yaml"
        
    async def create_agent_job(self, run_id: str, variation_id: int, repo_url: str, prompt: str) -> str:
        job_name = f"agent-{run_id}-{variation_id}"
        
        # Load and render template
        with open(self.job_template_path) as f:
            template = f.read()
        job_manifest = template.format(
            run_id=run_id,
            variation_id=variation_id,
            repo_url=repo_url,
            prompt=prompt.replace('"', '\\"'),
        )
        
        # Apply via kubectl
        process = subprocess.Popen(
            ["kubectl", "apply", "-f", "-", "--namespace", self.namespace],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = process.communicate(input=job_manifest)
        
        if process.returncode != 0:
            raise RuntimeError(f"Failed to create job: {stderr}")
        return job_name
```

### FastAPI with Kubernetes Integration

```python
# app/api/v1/runs.py
@router.post("", response_model=CreateRunResponse, status_code=202)
async def create_run(
    request: CreateRunRequest,
    background_tasks: BackgroundTasks,
    orchestrator = Depends(get_orchestrator),
    db: AsyncSession = Depends(get_session),
) -> CreateRunResponse:
    """Create a new agent run using Kubernetes Jobs."""
    # Validate
    if not request.github_url.startswith("https://github.com/"):
        raise HTTPException(status_code=400, detail="Only public GitHub repositories supported")
    
    # Create run in database
    run = await create_run_record(db, request)
    
    # Schedule Kubernetes job orchestration
    background_tasks.add_task(
        orchestrator.execute_variations,
        run_id=run.id,
        repo_url=request.github_url,
        prompt=request.prompt,
        variations=request.variations,
        use_batch_job=True  # Use Kubernetes batch jobs
    )
    
    return CreateRunResponse(
        run_id=run.id,
        stream_url=f"/api/v1/runs/{run.id}/stream",
        status="accepted"
    )
```

### Tiltfile Configuration

```python
# Tiltfile
# Build containers
docker_build('aideator-api', '.', dockerfile='./Dockerfile', target='api')
docker_build('aideator-agent', '.', dockerfile='./Dockerfile', target='agent')

# Deploy with Helm
k8s_yaml(helm(
    'deploy/charts/aideator',
    name='aideator',
    namespace='aideator',
    values=['deploy/values/local.yaml']
))

# Port forwarding
k8s_resource('aideator', port_forwards=['8000:8000'])
```

### Pydantic Validation

```python
from pydantic import BaseModel, Field, HttpUrl, field_validator

class CreateRunRequest(BaseModel):
    github_url: HttpUrl = Field(..., description="Public GitHub repository URL")
    prompt: str = Field(..., min_length=10, max_length=2000)
    variations: int = Field(default=3, ge=1, le=5)
    
    @field_validator('github_url')
    @classmethod
    def validate_github_url(cls, v: HttpUrl) -> HttpUrl:
        if not str(v).startswith('https://github.com/'):
            raise ValueError('Must be a GitHub URL')
        return v
```

## 🔐 Security Practices

### Kubernetes Security

- **RBAC**: Service account with minimal permissions
- **Secrets**: API keys stored as Kubernetes Secrets
- **Network Policies**: Restrict pod-to-pod communication (future)
- **Resource Limits**: Memory and CPU limits on all containers
- **Security Contexts**: Non-root users, read-only filesystems where possible

### SQL Injection Prevention

```python
# ❌ NEVER do this
query = f"SELECT * FROM runs WHERE id = '{run_id}'"

# ✅ Always use parameterized queries
result = await db.execute(
    select(Run).where(Run.id == run_id)
)
```

## 🧪 Testing Approach

### Unit Tests

```python
@pytest.mark.asyncio
async def test_create_kubernetes_job():
    k8s = KubernetesService()
    job_name = await k8s.create_agent_job(
        run_id="test-123",
        variation_id=0,
        repo_url="https://github.com/test/repo",
        prompt="Test prompt"
    )
    assert job_name == "agent-test-123-0"
```

### Integration Tests

```python
@pytest.mark.integration
async def test_full_kubernetes_flow():
    # Requires running cluster
    response = await async_client.post("/api/v1/runs", json={
        "github_url": "https://github.com/user/repo",
        "prompt": "Test prompt",
        "variations": 2
    })
    assert response.status_code == 202
    
    # Verify jobs created
    run_id = response.json()["run_id"]
    # Check Kubernetes jobs exist
```

## 🚨 Common Pitfalls to Avoid

### What I Never Do

- ❌ Hardcode cluster URLs or namespaces
- ❌ Skip resource limits on containers
- ❌ Use `kubectl exec` for normal operations
- ❌ Ignore Job TTL settings
- ❌ Mix development and production configs
- ❌ Return mock data in production endpoints
- ❌ Use synchronous I/O in async functions

### What I Always Do

- ✅ Use Kubernetes Jobs for batch workloads
- ✅ Set resource requests and limits
- ✅ Implement proper RBAC
- ✅ Use ConfigMaps and Secrets appropriately
- ✅ Add meaningful labels and annotations
- ✅ Test with Tilt before manual deployment
- ✅ Use `async def` for all route handlers
- ✅ Validate all inputs with Pydantic

## 🔄 Development Workflow

1. **Start Tilt**: `tilt up` - Handles everything automatically
2. **Make Changes**: Edit code, Tilt detects and rebuilds
3. **Test Locally**: Access http://localhost:8000
4. **Check Logs**: Use Tilt UI or `kubectl logs`
5. **Clean Up**: `tilt down` when done

## 📚 Key Technologies

### Core Stack

- **FastAPI** - Modern async web framework
- **Kubernetes** - Container orchestration
- **Helm** - Package manager for Kubernetes
- **Tilt** - Local Kubernetes development
- **kubectl** - Kubernetes CLI for log streaming
- **SQLite + SQLModel** - Database with async ORM
- **Pydantic** - Data validation

### Development Tools

- **pytest** - Testing framework
- **ruff** - Linting and formatting
- **mypy** - Type checking
- **k3d** - Local Kubernetes clusters
- **ctlptl** - Cluster management

## 🎯 MVP Success Criteria

The Kubernetes-native backend successfully:

1. Creates Kubernetes Jobs for each agent variation
2. Streams logs via kubectl to SSE endpoints
3. Manages Job lifecycle with TTL and cleanup
4. Provides RBAC-secured kubectl operations
5. Deploys via Helm with environment-specific values
6. Enables rapid development with Tilt

______________________________________________________________________

**I am your primary coding assistant for AIdeator. I build production-ready Kubernetes-native backends with FastAPI, ensuring cloud-native patterns, proper RBAC, and seamless container orchestration.**