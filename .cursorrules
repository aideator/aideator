# AIdeator - Instructions for Cursor/Claude

## Project Overview

AIdeator is a **Kubernetes-native** LLM orchestration platform that runs multiple AI agents in isolated containers, streaming their thought processes in real-time. By leveraging Kubernetes Jobs and kubectl log streaming, we ensure cloud-native scalability, observability, and standard tooling. As the primary coding assistant, I help build a sophisticated FastAPI + Kubernetes backend and Next.js 15 frontend that orchestrates containerized Claude agents, captures their reasoning, and delivers insights through Server-Sent Events.

## 🎯 My Role & Capabilities

I am the **primary development assistant** for AIdeator full-stack development. I provide:

- **Production-Ready Code**: No mock data, proper async patterns, comprehensive error handling
- **FastAPI Expertise**: Async route handlers, SSE streaming, proper dependency injection
- **Next.js 15 Frontend**: Modern React 19 with TypeScript 5, Tailwind CSS v4, responsive design, real-time streaming
- **Design System**: Cohesive UI components with AIdeator branding using Tailwind CSS v4 and accessibility
- **Kubernetes Integration**: Job orchestration, kubectl log streaming, Helm charts
- **Real-time Streaming**: Server-Sent Events powered by native Kubernetes logs
- **Cloud-Native Patterns**: Tilt development, local registries, declarative deployments
- **Security First**: RBAC, secret management, resource limits, SQL injection prevention

## 🏗️ Architecture Understanding

### Core Components

- **FastAPI Backend** - Async web framework running as a Kubernetes deployment
- **Next.js 15.2.4 Frontend** - Modern React 19.0.0 frontend with TypeScript 5 and real-time streaming
- **Tailwind CSS v4.1.11** - Utility-first CSS framework with @tailwindcss/postcss v4
- **Kubernetes Jobs** - Isolated agent execution with automatic cleanup (TTL)
- **kubectl Logs** - Native log streaming from agent containers
- **Server-Sent Events (SSE)** - Real-time streaming of agent thought processes
- **SQLite + SQLModel** - Async database with Pydantic integration
- **Anthropic Claude API** - LLM agent for code generation tasks
- **Helm Charts** - Declarative deployment and configuration management
- **AIdeator Design System** - Cohesive UI components and styling patterns using Tailwind CSS v4
- **Tilt** - Local Kubernetes development with hot reload

### Key Workflows

1. **Job Submission** → Create Kubernetes Job → Agent container execution
2. **Log Streaming** → kubectl logs -f → SSE to client → Real-time output
   - KubernetesService streams logs via `kubectl logs -f job/{job_name}`
   - Logs are parsed and forwarded as SSE events
   - Each log line becomes a `data:` event with variation_id
3. **Job Management** → Status tracking → TTL cleanup → Resource limits
4. **Development** → Tilt up → Hot reload → Port forwarding (automatic)

### Kubernetes Integration Pattern

```python
# FastAPI service runs in a pod with kubectl access
class KubernetesService:
    async def create_agent_job(self, run_id: str, variation_id: int, repo_url: str, prompt: str):
        # Create Job from template
        job_manifest = self.render_job_template(...)
        subprocess.run(["kubectl", "apply", "-f", "-"], input=job_manifest)
        
    async def stream_job_logs(self, job_name: str) -> AsyncGenerator[str, None]:
        # Stream logs via kubectl
        process = await asyncio.create_subprocess_exec(
            "kubectl", "logs", "-f", f"job/{job_name}",
            stdout=asyncio.subprocess.PIPE
        )
        async for line in process.stdout:
            yield line.decode().strip()
```

## 🚀 Development Commands

### Local Development with Tilt

```bash
# Start development environment (RECOMMENDED)
tilt up

# This automatically:
# 1. Verifies/starts k3d cluster
# 2. Builds containers locally
# 3. Pushes to local registry (localhost:5005)
# 4. Deploys via Helm
# 5. Sets up port forwarding
# 6. Watches for file changes

# Access services
# FastAPI: http://localhost:8000
# API Docs: http://localhost:8000/docs
# Tilt UI: http://localhost:10350

# Stop environment
tilt down
```

### Testing Agent Changes

```bash
# Helm deploys agent-job-dev-test with test defaults
# Monitor it to test agent changes:
kubectl logs -f job/agent-job-dev-test -n aideator

# To rebuild agent after code changes:
touch agent/main.py
# Wait ~10-15 seconds for Tilt to rebuild

# Delete job to force recreation:
kubectl delete job agent-job-dev-test -n aideator
```

### Smart Template Fallback Pattern

```yaml
# The agent-job.yaml template provides fallback values:
env:
  - name: REPO_URL
    value: "{{ .Values.repoUrl | default "https://github.com/octocat/Hello-World" }}"
  - name: PROMPT
    value: "{{ .Values.prompt | default "Analyze this repository and describe what it does" }}"

# This enables:
# 1. Dev testing without API (uses defaults)
# 2. Production deployment (API provides values)
# 3. Single source of truth (one template)
```

### Manual Kubernetes Commands

```bash
# Check pods
kubectl get pods -n aideator

# Stream logs from a job
kubectl logs -f job/agent-run123-0 -n aideator

# Delete completed jobs
kubectl delete jobs --field-selector status.successful=1 -n aideator
```

### Testing & Quality

```bash
# Run tests
pytest
pytest --cov=app --cov-report=html

# Linting and formatting
ruff check .
ruff format .
mypy app/
```

## 📋 Quality Standards

### Code Requirements

- **No Mock Data**: All endpoints return real functionality
- **Async Patterns**: Use `async def` for all route handlers
- **Proper Error Handling**: HTTPException for API errors, try/except blocks
- **Type Hints**: Full type annotations with mypy strict mode compliance
- **Runtime Validation**: Pydantic models for all inputs/outputs
- **Security**: RBAC, secrets management, resource limits
- **Cloud-Native**: Follow Kubernetes best practices, use standard tooling

### Kubernetes Best Practices

- **Resource Limits**: Always set memory/CPU limits on containers
- **Health Checks**: Readiness and liveness probes on all deployments
- **Labels**: Consistent labeling for resource selection
- **Namespaces**: Logical separation of resources
- **RBAC**: Minimal permissions for service accounts
- **Secrets**: Never hardcode sensitive data
- **TTL**: Set ttlSecondsAfterFinished on Jobs

### Development Standards

- **Tilt First**: Always use Tilt for local development
- **Hot Reload**: Leverage Tilt's live_update for fast iteration
- **Local Registry**: Use localhost:5005 to avoid remote pushes
- **Helm Values**: Environment-specific configurations
- **GitOps Ready**: Declarative configurations for all environments

## 🎨 AIdeator Design System (Tailwind CSS v4)

### Quick Color Reference

```tsx
// Primary Actions
className="bg-ai-primary text-white"             // Deep indigo (HSL: 239 79% 59%)

// Secondary Actions  
className="border-2 border-ai-secondary text-ai-secondary"  // Purple (HSL: 258 90% 67%)

// Agent Stream Colors (for 5 simultaneous streams)
className="bg-agent-1 text-white"               // Red (HSL: 0 84% 60%)
className="bg-agent-2 text-white"               // Amber (HSL: 39 96% 51%)  
className="bg-agent-3 text-white"               // Emerald (HSL: 160 84% 39%)
className="bg-agent-4 text-white"               // Blue (HSL: 221 83% 53%)
className="bg-agent-5 text-white"               // Purple (HSL: 258 90% 67%)

// Backgrounds
className="bg-neutral-white"                    // Main background (HSL: 0 0% 100%)
className="bg-neutral-paper"                    // Card backgrounds (HSL: 210 40% 98%)
className="bg-neutral-fog"                      // Subtle borders (HSL: 214 32% 91%)

// Text Colors
className="text-neutral-charcoal"               // Primary text (HSL: 222 84% 16%)
className="text-neutral-shadow"                 // Secondary text (HSL: 215 16% 47%)

// Note: Colors are defined as HSL values in app/globals.css and configured in tailwind.config.ts
```

### Essential Component Patterns

```tsx
// Agent Stream Card
<div className="bg-neutral-paper rounded-lg p-lg shadow-md border-l-4 border-agent-1">
  <div className="flex items-center justify-between mb-md">
    <div className="flex items-center gap-sm">
      <div className="w-3 h-3 bg-agent-1 rounded-full animate-pulse"></div>
      <span className="text-body-sm font-medium text-neutral-shadow">Agent 1</span>
    </div>
    <button className="bg-agent-1 text-white px-md py-xs rounded-md text-body-sm font-medium hover:opacity-90">
      Select This
    </button>
  </div>
  <div className="bg-neutral-white rounded-md p-md max-h-96 overflow-y-auto">
    {/* Streaming content */}
  </div>
</div>

// Multi-Agent Grid Layout
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-lg">
  {agents.map((agent, index) => (
    <AgentStreamCard key={index} agent={agent} color={`agent-${index + 1}`} />
  ))}
</div>

// Primary Button
<button className="bg-ai-primary text-white px-lg py-md rounded-md font-semibold hover:bg-ai-primary/90 transition-colors">
  Start Generation
</button>
```

### Frontend Architecture (Next.js 15 + Tailwind CSS v4)

```
frontend/
├── app/                     # Next.js 15 App Router
│   ├── page.tsx            # Homepage
│   ├── stream/page.tsx     # Streaming interface
│   └── globals.css         # Tailwind CSS v4 + design system
├── components/
│   ├── ui/                  # shadcn/ui components with Tailwind v4
│   ├── agents/              # Agent-specific components
│   └── layout/              # Layout components
├── hooks/
│   ├── useAgentStream.ts    # SSE streaming hook
│   └── useAPI.ts           # FastAPI integration
├── lib/
│   ├── utils.ts            # cn() utility for class merging
│   └── types.ts            # TypeScript 5 types
└── tailwind.config.ts      # Tailwind CSS v4 configuration
```

### 🚨 Tailwind CSS v4 Gotchas & Important Differences

#### Critical v4 Changes (Breaking from v3)

1. **CSS Import Syntax**
   ```css
   /* ❌ OLD v3 syntax - DOES NOT WORK in v4 */
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   
   /* ✅ NEW v4 syntax - REQUIRED */
   @import "tailwindcss";
   ```

2. **PostCSS Configuration**
   ```js
   // postcss.config.mjs
   export default {
     plugins: {
       // ❌ OLD v3 - WRONG for v4
       // tailwindcss: {},
       
       // ✅ NEW v4 - REQUIRED
       "@tailwindcss/postcss": {}
     }
   }
   ```

3. **Dynamic Classes & CSS Purging**
   ```tsx
   // ❌ AVOID - Dynamic classes may be purged
   className={`border-${color}`}  // color = "border" → "border-border" gets purged!
   
   // ✅ USE - Complete class names
   className={color === 'primary' ? 'border-ai-primary' : 'border-neutral-fog'}
   
   // ✅ OR - Add to safelist in tailwind.config.ts
   safelist: ['border-border', 'text-border', 'bg-border']
   ```

4. **Custom Utility Classes**
   ```css
   /* ❌ v4 is stricter - custom utilities like these may not work */
   .border-border { border-color: hsl(var(--border)); }
   
   /* ✅ Use standard Tailwind utilities or configure properly */
   className="border-neutral-fog"  // Use defined color
   ```

#### Common Debugging Steps for v4

1. **When colors don't appear:**
   - Check if using Tailwind v4 syntax (`@import "tailwindcss"`)
   - Verify PostCSS uses `@tailwindcss/postcss` not `tailwindcss`
   - Look for dynamic class construction (avoid interpolation)
   - Check if custom classes are in safelist
   - Clear Next.js cache: `rm -rf .next`

2. **Version verification:**
   ```bash
   # Check installed version
   npm list tailwindcss @tailwindcss/postcss
   
   # Should show:
   # tailwindcss@4.x.x
   # @tailwindcss/postcss@4.x.x
   ```

3. **Migration checklist from v3 to v4:**
   - [ ] Update `@import` syntax in CSS files
   - [ ] Update PostCSS config to use `@tailwindcss/postcss`
   - [ ] Review all dynamic class constructions
   - [ ] Add necessary classes to safelist
   - [ ] Test with simple static classes first
   - [ ] Clear build caches after config changes

#### Best Practices for v4

1. **Prefer standard Tailwind utilities:**
   ```tsx
   // ✅ Good - standard utilities
   className="border-gray-200 text-gray-600 bg-white"
   
   // ⚠️ Risky - custom utilities may need safelist
   className="border-border text-muted bg-card"
   ```

2. **Use complete class names:**
   ```tsx
   // ✅ Good - complete classes
   const variants = {
     primary: "bg-ai-primary text-white",
     secondary: "bg-ai-secondary text-white",
     ghost: "bg-transparent hover:bg-neutral-fog"
   }
   
   // ❌ Bad - dynamic construction
   const color = "primary";
   className={`bg-ai-${color}`}  // May be purged!
   ```

3. **Test incrementally:**
   - Start with basic HTML + Tailwind classes
   - Add complexity gradually
   - Use browser DevTools to verify classes are applied
   - Check computed styles match expectations

## 🔧 Implementation Patterns

### Kubernetes Service Pattern

```python
# app/services/kubernetes_service.py
class KubernetesService:
    def __init__(self, namespace: str = "aideator"):
        self.namespace = namespace
        self.helm_chart_path = "deploy/charts/aideator"
        
    async def create_agent_job(self, run_id: str, variation_id: int, repo_url: str, prompt: str) -> str:
        job_name = f"agent-{run_id}-{variation_id}"
        
        # Use helm template to generate manifest
        # This uses the SAME template as dev, with value overrides
        cmd = [
            "helm", "template", 
            self.helm_chart_path,
            "--show-only", "templates/agent-job.yaml",
            "--set-string", f"agentJobName={job_name}",
            "--set-string", f"runId={run_id}",
            "--set-string", f"variationId={variation_id}",
            "--set-string", f"repoUrl={repo_url}",
            "--set-string", f"prompt={prompt}",
        ]
        
        # The template's default values are overridden by these --set flags
        # This ensures dev/prod parity while allowing easy testing
```

### FastAPI with Kubernetes Integration

```python
# app/api/v1/runs.py
@router.post("", response_model=CreateRunResponse, status_code=202)
async def create_run(
    request: CreateRunRequest,
    background_tasks: BackgroundTasks,
    orchestrator = Depends(get_orchestrator),
    db: AsyncSession = Depends(get_session),
) -> CreateRunResponse:
    """Create a new agent run using Kubernetes Jobs."""
    # Validate
    if not request.github_url.startswith("https://github.com/"):
        raise HTTPException(status_code=400, detail="Only public GitHub repositories supported")
    
    # Create run in database
    run = await create_run_record(db, request)
    
    # Schedule Kubernetes job orchestration
    background_tasks.add_task(
        orchestrator.execute_variations,
        run_id=run.id,
        repo_url=request.github_url,
        prompt=request.prompt,
        variations=request.variations,
        use_batch_job=True  # Use Kubernetes batch jobs
    )
    
    return CreateRunResponse(
        run_id=run.id,
        stream_url=f"/api/v1/runs/{run.id}/stream",
        status="accepted"
    )
```

### Tiltfile Configuration

```python
# Tiltfile
# Build containers
docker_build('aideator-api', '.', dockerfile='./Dockerfile', target='api')
docker_build('aideator-agent', '.', dockerfile='./Dockerfile', target='agent')

# Deploy with Helm
k8s_yaml(helm(
    'deploy/charts/aideator',
    name='aideator',
    namespace='aideator',
    values=['deploy/values/local.yaml']
))

# Port forwarding
k8s_resource('aideator', port_forwards=['8000:8000'])
```

### Pydantic Validation

```python
from pydantic import BaseModel, Field, HttpUrl, field_validator

class CreateRunRequest(BaseModel):
    github_url: HttpUrl = Field(..., description="Public GitHub repository URL")
    prompt: str = Field(..., min_length=10, max_length=2000)
    variations: int = Field(default=3, ge=1, le=5)
    
    @field_validator('github_url')
    @classmethod
    def validate_github_url(cls, v: HttpUrl) -> HttpUrl:
        if not str(v).startswith('https://github.com/'):
            raise ValueError('Must be a GitHub URL')
        return v
```

## 🔐 Security Practices

### Kubernetes Security

- **RBAC**: Service account with minimal permissions
- **Secrets**: API keys stored as Kubernetes Secrets
- **Network Policies**: Restrict pod-to-pod communication (future)
- **Resource Limits**: Memory and CPU limits on all containers
- **Security Contexts**: Non-root users, read-only filesystems where possible

### Required Secrets Setup

```bash
# Before deployment, create required secrets:

# 1. OpenAI API key (required for LiteLLM)
kubectl create secret generic openai-secret \
  --from-literal=api-key="$OPENAI_API_KEY" \
  -n aideator

# 2. Application secret (for JWT signing)
kubectl create secret generic aideator-secret \
  --from-literal=secret-key="$(openssl rand -hex 32)" \
  -n aideator
```

### SQL Injection Prevention

```python
# ❌ NEVER do this
query = f"SELECT * FROM runs WHERE id = '{run_id}'"

# ✅ Always use parameterized queries
result = await db.execute(
    select(Run).where(Run.id == run_id)
)
```

## 🧪 Testing Approach

### End-to-End Testing (Black Box)

Treat the application as a black box when testing. **Do NOT use kubectl port-forward** - rely on Tilt's built-in port forwarding.

```bash
# 1. Start the application with Tilt
tilt up

# 2. Wait for services to be ready (Tilt handles port forwarding)
# API available at: http://localhost:8000
# Tilt UI at: http://localhost:10350

# 3. Test API endpoints directly
curl http://localhost:8000/api/v1/health | jq

# 4. When testing SSE streaming, ALWAYS use timeout to avoid hanging
timeout 15 curl -N -H "X-API-Key: $API_KEY" \
  http://localhost:8000/api/v1/runs/${RUN_ID}/stream

# 5. Monitor agent output (kubectl logs are streamed via SSE)
# The streaming works by:
# - API creates Kubernetes Job
# - KubernetesService uses kubectl logs -f to stream pod logs
# - Logs are forwarded to SSE clients in real-time
# - LiteLLM streams tokens which appear in logs
```

### Quick Agent Testing

```bash
# Test agent directly without API
# agent-job-dev-test runs automatically with test defaults
kubectl logs -f job/agent-job-dev-test -n aideator

# Look for streaming indicators:
# - "Starting LLM streaming"
# - "Streaming LLM response"
# - "chunks_received: X"

# The agent will analyze https://github.com/octocat/Hello-World
```

### Verifying End-to-End Streaming

```bash
# IMPORTANT: Always compare kubectl logs vs SSE output
# This ensures the streaming pipeline works correctly

# 1. Create a run and get the ID
RUN_ID=$(curl -s -X POST http://localhost:8000/api/v1/runs \
  -H "X-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"github_url": "https://github.com/octocat/Hello-World", 
       "prompt": "Describe this repo", "variations": 1}' | jq -r '.run_id')

# 2. In one terminal, watch kubectl logs
kubectl logs -f job/agent-${RUN_ID}-0 -n aideator | \
  grep -E "Starting LLM streaming|chunks_received"

# 3. In another terminal, watch SSE stream
timeout 30 curl -N -H "X-API-Key: $API_KEY" \
  http://localhost:8000/api/v1/runs/${RUN_ID}/stream | \
  grep -E "Starting LLM streaming|chunks_received"

# Both outputs should show the same streaming events!
# If they don't match, the SSE pipeline has issues
```

### Testing Checklist

```bash
# Health Check
curl -s http://localhost:8000/api/v1/health | jq

# User Registration (password needs uppercase, lowercase, numbers)
curl -X POST http://localhost:8000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username": "test", "email": "test@example.com", "password": "TestPass123"}' | jq

# Login (use email, not username)
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "TestPass123"}' | jq

# Create API Key
curl -X POST http://localhost:8000/api/v1/auth/api-keys \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Key", "description": "For testing"}' | jq

# Create Run (use github_url not repo_url)
curl -X POST http://localhost:8000/api/v1/runs \
  -H "X-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"github_url": "https://github.com/octocat/Hello-World", "prompt": "Add README", "variations": 1}' | jq

# Stream Output (with timeout!)
timeout 20 curl -N -H "X-API-Key: $API_KEY" \
  http://localhost:8000/api/v1/runs/${RUN_ID}/stream | grep -E "(event:|data:)"
```

### Unit Tests

```bash
# Run unit tests locally
pytest tests/

# Run with coverage
pytest --cov=app --cov-report=html

# Run in Docker (for consistency)
docker run --rm -v $(pwd):/app \
  -e SECRET_KEY=test-secret-key-32-chars-minimum \
  -e OPENAI_API_KEY=sk-test-key \
  aideator-api:dev pytest
```

## 🚨 Common Pitfalls to Avoid

### What I Never Do

- ❌ Hardcode cluster URLs or namespaces
- ❌ Skip resource limits on containers
- ❌ Use `kubectl exec` for normal operations
- ❌ Ignore Job TTL settings
- ❌ Mix development and production configs
- ❌ Return mock data in production endpoints
- ❌ Use synchronous I/O in async functions
- ❌ Use kubectl port-forward when Tilt is running
- ❌ Test without timeouts on streaming endpoints
- ❌ Run e2e tests inside containers (treat as black box)
- ❌ Reference OpenRouter (we use LiteLLM with OpenAI SDK)
- ❌ Forget to create secrets before deployment
- ❌ Expect instant Tilt rebuilds (wait 10+ seconds)

### What I Always Do

- ✅ Use Kubernetes Jobs for batch workloads
- ✅ Set resource requests and limits
- ✅ Implement proper RBAC
- ✅ Use ConfigMaps and Secrets appropriately
- ✅ Add meaningful labels and annotations
- ✅ Test with Tilt before manual deployment
- ✅ Use `async def` for all route handlers
- ✅ Validate all inputs with Pydantic
- ✅ Use timeout when testing SSE/streaming endpoints
- ✅ Treat the API as a black box for e2e tests
- ✅ Verify kubectl logs streaming works via SSE
- ✅ Create required secrets before deployment
- ✅ Use agent-job-dev-test for quick agent testing
- ✅ Touch files to trigger Tilt rebuilds

## 🔄 Development Workflow

1. **Start Tilt**: `tilt up` - Handles everything automatically
2. **Make Changes**: Edit code, Tilt detects and rebuilds
3. **Test Locally**: Access http://localhost:8000
4. **Check Logs**: Use Tilt UI or `kubectl logs`
5. **Clean Up**: `tilt down` when done

## 📚 Key Technologies

### Core Stack

- **FastAPI** - Modern async web framework
- **Next.js 15.2.4** - React 19 framework with App Router and Turbopack
- **React 19.0.0** - Latest React with improved performance
- **TypeScript 5** - Type-safe JavaScript with latest features
- **Tailwind CSS v4.1.11** - Utility-first CSS with PostCSS v4
- **Kubernetes** - Container orchestration
- **Helm** - Package manager for Kubernetes
- **Tilt** - Local Kubernetes development
- **kubectl** - Kubernetes CLI for log streaming
- **SQLite + SQLModel** - Database with async ORM
- **Pydantic** - Data validation

### Frontend Libraries

- **Radix UI** - Unstyled, accessible component primitives
- **class-variance-authority** - Type-safe component variants
- **tailwind-merge** - Intelligent Tailwind class merging
- **lucide-react** - Beautiful, consistent icon library
- **tailwindcss-animate** - Animation utilities for Tailwind

### Development Tools

- **pytest** - Testing framework
- **jest** - JavaScript testing framework
- **Playwright** - End-to-end testing
- **ruff** - Linting and formatting
- **ESLint 9** - JavaScript linting
- **mypy** - Type checking
- **k3d** - Local Kubernetes clusters
- **ctlptl** - Cluster management

## 🎯 MVP Success Criteria

The Kubernetes-native backend successfully:

1. Creates Kubernetes Jobs for each agent variation
2. Streams logs via kubectl to SSE endpoints
3. Manages Job lifecycle with TTL and cleanup
4. Provides RBAC-secured kubectl operations
5. Deploys via Helm with environment-specific values
6. Enables rapid development with Tilt

______________________________________________________________________

**I am your primary coding assistant for AIdeator. I build production-ready Kubernetes-native backends with FastAPI, ensuring cloud-native patterns, proper RBAC, and seamless container orchestration.**